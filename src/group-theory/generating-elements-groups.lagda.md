# Generating elements of groups

```agda
module group-theory.generating-elements-groups where
```

<details><summary>Imports</summary>

```agda
open import elementary-number-theory.integers
open import elementary-number-theory.natural-numbers

open import foundation.action-on-identifications-functions
open import foundation.coproduct-types
open import foundation.dependent-pair-types
open import foundation.embeddings
open import foundation.identity-types
open import foundation.injective-maps
open import foundation.propositional-maps
open import foundation.propositional-truncations
open import foundation.propositions
open import foundation.sets
open import foundation.subtypes
open import foundation.surjective-maps
open import foundation.unit-type
open import foundation.universe-levels

open import group-theory.abelian-groups
open import group-theory.commuting-elements-groups
open import group-theory.conjugation
open import group-theory.free-groups-with-one-generator
open import group-theory.full-subgroups
open import group-theory.groups
open import group-theory.homomorphisms-groups
open import group-theory.images-of-group-homomorphisms
open import group-theory.integer-powers-of-elements-groups
open import group-theory.normal-subgroups
open import group-theory.quotient-groups
open import group-theory.subgroups
open import group-theory.subgroups-generated-by-elements-groups
open import group-theory.subsets-groups
open import group-theory.trivial-group-homomorphisms
```

</details>

## Idea

An element $g$ of a [group](group-theory.groups.md) `G` is said to be a
**generating element** if the unique morphism `g̃ : ℤ → G` equipped with an
identification `g̃(1) = g` is [surjective](foundation.surjective-maps.md). [Equivalently](foundation.logical-equivalences.md), `g` is a generating
element if the [subgroup](group-theory.subgroups.md) `⟨g⟩` of `G`
[generated by the element](group-theory.subgroups-generated-by-elements-groups.md)
`g` is the [full subgroup](group-theory.full-subgroups.md) of `G`.

## Definitions

### Generating elements

We state the definition of generating elements in four equivalent ways: An
element `g` generates the group `G` if

1. the subgroup generated by the element `g` is full, or if
2. the full subgroup of `G` is generated by the element `g`, or if
3. the group homomorphism `g̃ : ℤ → G` mapping `1` to `g` is surjective, or if
4. the evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`.

#### The standard definition

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  is-generating-element-prop-Group : Prop l1
  is-generating-element-prop-Group =
    is-full-prop-Subgroup G (subgroup-element-Group G g)

  is-generating-element-Group : UU l1
  is-generating-element-Group = type-Prop is-generating-element-prop-Group

  is-prop-is-generating-element-Group : is-prop is-generating-element-Group
  is-prop-is-generating-element-Group =
    is-prop-type-Prop is-generating-element-prop-Group
```

#### The definition where the full subgroup is asserted to be generated by the element

```agda
  is-subgroup-generated-by-element-full-Subgroup : UUω
  is-subgroup-generated-by-element-full-Subgroup =
    is-subgroup-generated-by-element-Group G g (full-Subgroup lzero G)
```

#### The definition where the unique morphism `ℤ → G` mapping `1` to `g` is surjective

```agda
module _
  {l1 : Level} (G : Group l1)
  where

  is-surjective-hom-element-Group : type-Group G → UU l1
  is-surjective-hom-element-Group g =
    is-surjective (map-hom-element-Group G g)
```

#### The definition where the evaluation map `hom(G,H) → H` at `g` is an embedding for every `H`

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  is-emb-ev-element-hom-Group' : (l : Level) → UU (l1 ⊔ lsuc l)
  is-emb-ev-element-hom-Group' l =
    (H : Group l) → is-emb (ev-element-hom-Group G H g)

  is-emb-ev-element-hom-Group : UUω
  is-emb-ev-element-hom-Group =
    {l : Level} → is-emb-ev-element-hom-Group' l

  is-prop-map-ev-element-hom-Group : UUω
  is-prop-map-ev-element-hom-Group =
    {l : Level} (H : Group l) → is-prop-map (ev-element-hom-Group G H g)
```

### The subset of generating elements of a group

```agda
module _
  {l1 : Level} (G : Group l1)
  where

  generating-element-Group : subset-Group l1 G
  generating-element-Group x = is-generating-element-prop-Group G x
```

## Properties

### The four definitions of generating elements are equivalent

#### An element is generating if and only if it generates the full subgroup

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  is-generating-element-is-subgroup-generated-by-element-full-Subgroup :
    is-subgroup-generated-by-element-full-Subgroup G g →
    is-generating-element-Group G g
  is-generating-element-is-subgroup-generated-by-element-full-Subgroup H x =
    leq-subgroup-is-subgroup-generated-by-element-Group G g
      ( full-Subgroup lzero G)
      ( subgroup-element-Group G g)
      ( H)
      ( contains-element-subgroup-element-Group G g)
      ( x)
      ( raise-star)

  is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group :
    is-generating-element-Group G g →
    is-subgroup-generated-by-element-full-Subgroup G g
  pr1
    ( is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
      H K)
    ( u)
    ( x)
    ( v) =
    leq-subgroup-element-Group G g K u x (H x)
  pr2
    ( is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
      H K)
    ( u) =
    u g raise-star
```

#### An element `g` is generating if and only if the unique map `g̃ : ℤ → G` is surjective

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  is-generating-element-is-surjective-hom-element-Group' :
    (x : type-Group G) (k : ℤ) (p : map-hom-element-Group G g k ＝ x) →
    is-in-subgroup-element-Group G g x
  is-generating-element-is-surjective-hom-element-Group' ._ k refl =
    contains-powers-subgroup-element-Group G g k

  is-generating-element-is-surjective-hom-element-Group :
    is-surjective-hom-element-Group G g → is-generating-element-Group G g
  is-generating-element-is-surjective-hom-element-Group H x =
    apply-universal-property-trunc-Prop
      ( H x)
      ( subset-subgroup-element-Group G g x)
      ( λ (k , p) →
        is-generating-element-is-surjective-hom-element-Group' x k p)

  is-surjective-hom-element-is-generating-element-Group :
    is-generating-element-Group G g → is-surjective-hom-element-Group G g
  is-surjective-hom-element-is-generating-element-Group H x =
    leq-subgroup-is-subgroup-generated-by-element-Group G g
      ( full-Subgroup lzero G)
      ( image-hom-element-Group G g)
      ( is-subgroup-generated-by-element-full-subgroup-is-generating-element-Group
        ( G)
        ( g)
        ( H))
      ( contains-element-image-hom-element-Group G g)
      ( x)
      ( raise-star)
```

#### If the evaluation map `hom(G,H) → H` at `g` is an embedding for every group `H`, then `g̃ : ℤ → G` is surjective

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  (U : is-emb-ev-element-hom-Group G g)
  where

  compute-conjugation-is-emb-ev-element-hom-Group :
    htpy-hom-Group G G (conjugation-hom-Group G g) (id-hom-Group G)
  compute-conjugation-is-emb-ev-element-hom-Group =
    htpy-eq-hom-Group G G
      ( conjugation-hom-Group G g)
      ( id-hom-Group G)
      ( is-injective-is-emb (U G)
        ( inv (transpose-eq-mul-Group G refl)))

  commute-is-emb-ev-element-hom-Group :
    (x : type-Group G) → mul-Group G g x ＝ mul-Group G x g
  commute-is-emb-ev-element-hom-Group x =
    inv
      ( inv-transpose-eq-mul-Group G
        ( inv (compute-conjugation-is-emb-ev-element-hom-Group x)))

  compute-conjugation-is-emb-ev-element-hom-Group' :
    (x : type-Group G) → conjugation-Group G x g ＝ g
  compute-conjugation-is-emb-ev-element-hom-Group' x =
    inv (transpose-eq-mul-Group G (commute-is-emb-ev-element-hom-Group x))

  abstract
    is-normal-image-hom-element-is-emb-ev-element-hom-Group :
      is-normal-Subgroup G (image-hom-element-Group G g)
    is-normal-image-hom-element-is-emb-ev-element-hom-Group x (y , p) =
      apply-universal-property-trunc-Prop p
        ( subset-image-hom-element-Group G g (conjugation-Group G x y))
        ( λ { (k , refl) →
              is-closed-under-eq-image-hom-element-Group' G g
                ( unit-trunc-Prop (k , refl))
                ( ( preserves-integer-powers-conjugation-Group G k x g) ∙
                  ( ap
                    ( integer-power-Group G k)
                    ( compute-conjugation-is-emb-ev-element-hom-Group' x)))})

  private
    N : Normal-Subgroup l1 G
    pr1 N = image-hom-element-Group G g
    pr2 N = is-normal-image-hom-element-is-emb-ev-element-hom-Group

    H : Group l1
    H = quotient-Group G N

    q : type-hom-Group G H
    q = quotient-hom-Group G N

  abstract
    is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group :
      is-trivial-hom-Group G H q
    is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group =
      htpy-eq-hom-Group G H q
        ( trivial-hom-Group G H)
        ( is-injective-is-emb
          ( U H)
          ( is-in-kernel-quotient-hom-is-in-Normal-Subgroup G N
            ( contains-element-image-hom-element-Group G g)))

  is-surjective-hom-element-is-emb-ev-element-hom-Group :
    is-surjective-hom-element-Group G g
  is-surjective-hom-element-is-emb-ev-element-hom-Group x =
    is-in-normal-subgroup-is-in-kernel-quotient-hom-Group G N
      ( is-trivial-quotient-hom-image-hom-element-is-emb-ev-element-hom-Group x)
```

#### A group element `g : G` is generating if and only if for every group `H` the evaluation map `hom(G,H) → H` at `g` is an embedding

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  is-prop-map-ev-element-is-generating-element-Group :
    is-generating-element-Group G g → is-prop-map-ev-element-hom-Group G g
  is-prop-map-ev-element-is-generating-element-Group U H y =
    is-prop-all-elements-equal
      ( λ (h , p) (k , q) →
        eq-type-subtype
          ( λ u → Id-Prop (set-Group H) (ev-element-hom-Group G H g u) y)
          ( eq-htpy-hom-Group G H
            ( λ x →
              apply-universal-property-trunc-Prop
                ( is-surjective-hom-element-is-generating-element-Group G g U x)
                ( Id-Prop
                  ( set-Group H)
                  ( map-hom-Group G H h x)
                  ( map-hom-Group G H k x))
                ( λ { (z , refl) →
                      eq-integer-power-hom-Group G H h k z g (p ∙ inv q)}))))

  is-emb-ev-element-is-generating-element-Group :
    is-generating-element-Group G g → is-emb-ev-element-hom-Group G g
  is-emb-ev-element-is-generating-element-Group U H =
    is-emb-is-prop-map (is-prop-map-ev-element-is-generating-element-Group U H)

  is-generating-element-is-emb-ev-element-hom-Group :
    is-emb-ev-element-hom-Group G g → is-generating-element-Group G g
  is-generating-element-is-emb-ev-element-hom-Group U =
    is-generating-element-is-surjective-hom-element-Group G g
      ( is-surjective-hom-element-is-emb-ev-element-hom-Group G g U)
```

### If `g` is a generating element of `G`, then `G` is abelian

```agda
module _
  {l1 : Level} (G : Group l1) (g : type-Group G)
  where

  abstract
    commutative-mul-is-surjective-hom-element-Group :
      (U : is-surjective-hom-element-Group G g) →
      (x y : type-Group G) → commute-Group G x y
    commutative-mul-is-surjective-hom-element-Group U x y =
      apply-twice-universal-property-trunc-Prop
        ( U x)
        ( U y)
        ( Id-Prop (set-Group G) (mul-Group G x y) (mul-Group G y x))
        ( λ { (k , refl) (l , refl) →
              commute-integer-powers-Group G k l refl})

  commutative-mul-is-generating-element-Group :
    (U : is-generating-element-Group G g) →
    (x y : type-Group G) → commute-Group G x y
  commutative-mul-is-generating-element-Group U =
    commutative-mul-is-surjective-hom-element-Group
      ( is-surjective-hom-element-is-generating-element-Group G g U)

abelian-group-generating-element-Group :
  {l : Level} (G : Group l) → type-subtype (generating-element-Group G) → Ab l
pr1 (abelian-group-generating-element-Group G (g , u)) = G
pr2 (abelian-group-generating-element-Group G (g , u)) =
  commutative-mul-is-generating-element-Group G g u
```

### If `g` is a generating element of `G`, then the evaluation map `hom(G,G) → G` is an isomorphism of groups

```agda
module _
  {l : Level} (G : Group l) (g : type-Group G)
  (U : is-generating-element-Group G g)
  where

  map-endomorphism-element-Group :
    type-Group G → type-Group G → type-Group G
  map-endomorphism-element-Group x y = {!!}
```
